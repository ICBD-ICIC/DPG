#!/usr/bin/env python
"""
Script to generate the program dataset and analyze the relationship of the 
parameters and metrics of the DeLP Program Generator (DPG)

Some abbreviations:
    - drule: Defeasible Rule
    - srule: Strict Rule
    - head: Consequent of a rule (conclusion)
"""

import random
import statistics as stat
import csv
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import os
import sys
import json

global dummyMode
#dummyMode=True
dummyMode=False

# Number of programs to generate for each value variation
global n_programs
n_programs = 50

"""
### DPG Parameters ###
- KBBASE_SIZE: Minimum number of facts and presumptions.
- FACT_PROB: Probability that an element is a fact.
- NEG_PROB: Probability to create a negated atom.
- DRULE_PROB: Probability to create a defeasible rule (1 - DRULE_PROB to srule).
- MAX_RULESPERHEAD: Maximum number of rules with the same head.
- MAX_BODYSIZE: Maximum number of literals in the body of an argument.
- MIN_ARGSLEVEL: Minimum number of distinct arguments in a level.
- LEVELS: Program levels.
- RAMIFICATION: Maximum number of defeaters for an argument of the top level.
- TREE_HEIGHT: Maximum height of dialectical trees.
"""
params = (
       "KBBASE_SIZE;"
       "FACT_PROB;"
       "NEG_PROB;" 
       "DRULE_PROB;"
       "MAX_RULESPERHEAD;" 
       "MAX_BODYSIZE;" 
       "MIN_ARGSLEVEL;" 
       "LEVELS;"
       "RAMIFICATION;"
       "TREE_HEIGHT").split(";")

"""
### DeLP Metrics ###
- n_rules: Total number of rules (srules and drules).
- n_facts_pres: Number of facts and presumptions.
- mddl: Mean length of defeasible derivation of any argument.
- h: Mean maximum length of argumentation lines.
- t: Mean number of argument lines arising from an argument.
- tau: Mean number of dialectical trees.
"""
metrics=("n_rules;"
       "n_facts_pres;"
       "mddl;"
       "h;"
       "t;"
       "tau").split(";")

# The minimum value for each parameters
params_min = [1,0.1,0.1,0.1,1,1,1,2,1,1]

# The maximum value for each parameters
params_max = [10,0.9,0.9,0.9,10,10,10,10,10,10]

# The parameter steps 
params_steps = [2,0.1,0.1,0.1,1,1,1,1,1,1]

def method1(dp: str, parameters: list) -> str:
    """
    Given a directory path and parameters, generate a number of programs in 
    that directory and with the specified parameters. Return the directory
    path on completion
    Args:
        dp: Directory Path
        parameters: List of parameters values
    """
    if dummyMode:
        return "filepathDUMMY" + str(parameters)
        sys.exit()
    else:
        os.mkdir(dp)
        parameters_values = {params[i]:parameters[i] for i in range(len(params))}
        parameters_values['INNER_PROB'] = 0.0
        parameters_values['N_PROGRAMS'] = n_programs
        parameters_values['PREF_CRITERION'] = "more_specific"
        with open(dp + '/parameters.json', 'w') as output:
            json.dump(parameters_values, output)
        return dp
        

# method2(<string>:fp) given a DELP filepath returns the list [M1, M2, M3, M4,..] of its exact metrics
#def method2(fp):
#	if(dummyMode):
#		return [random.randint(0, 100000) for x in metrics]
#	else:
#		return "MARIO PLEASE CALL YOUR METHOD"
#
#
## method3(<string>:fp) given a DELP filepath returns the running time in milliseconds needed to comptute the warrant statuses of all lits
#def method3(fp):
#	if(dummyMode):
#		return random.randint(0, 100000)
#	else:
#		return "MARIO PLEASE CALL YOUR METHOD"
#
#
#########
#########   From now on Gianni has the w-lock
#########
def create_datasets(dp):
    """
    Return a dictionary where each key is a parameter name (say p1) 
    and the value is a set of delp filepath generated by varying p1 
    only and keeping the others constant (an average value is assumed)
    """ 
    d_programs = {}
    for i in range(len(params)):
        d_programs[params[i]]=[method1(dp + params[i] + str(x),[params_min[y] if y!=i else x for y in range(len(params))]) for x in range(params_min[i],params_max[i],params_steps[i])]
    return d_programs
#
#
#def retrive_params(fp):
#    """
#    Given a filepath string, it returns a list of paramenter used in generating 
#    that delp program
#    """
#	return fp[fp.find("[")+1:fp.rfind("]")].split(",")
#
#
#def generate_csv(d,csv_fp):
#    """
#    Given the dictionary d_programs it computes the csv for each program. 
#    A filepath for csv is needed as input
#    """
#    with open(csv_fp, 'w') as f:
#    writer = csv.writer(f)	
#    writer.writerow(params+metrics+["time"])
#    for k in d.keys():
#	    for delp in d[k]:
#		    writer.writerow(retrive_params(delp)+method2(delp)+[str(method3(delp))])
#	f.close()
#
#
#def print_matrix_plot(labels,matrix,filepath):
#    """
#    ???
#    """
#	fig_cor, axes_cor = plt.subplots(1,1)
#	fig_cor.set_size_inches(6, 6)
#	myimage = axes_cor.imshow(matrix)
#	plt.colorbar(myimage)
#	axes_cor.set_xticks(np.arange(0,matrix.shape[0], matrix.shape[0]*1.0/len(labels)))
#	axes_cor.set_yticks(np.arange(0,matrix.shape[1], matrix.shape[1]*1.0/len(labels)))
#	axes_cor.set_xticklabels(labels)
#	axes_cor.set_yticklabels(labels)
#	plt.draw()
#	plt.savefig(filepath)


######
###### CREATING THE DATASET
######
#d=create_datasets()


######
###### GENERATING CSV
######
#generate_csv(create_datasets(), dir+"delpGeneratorMario.csv")


######
###### GENERATING PLOTS FOR STEP 1
######
#n_p=0
#for k in d.keys():
#	parameter_k=[x for x in range(params_min[n_p],params_max[n_p]+1,params_steps[n_p])]
#	data = {k: parameter_k}
#	for m in metrics:
#		data[m]=[]
#	data["time"]=[]
#	for delp in d[k]:
#		metrics_d_k=method2(delp)
#		for i in range(len(metrics_d_k)):
#			data[metrics[i]].append(metrics_d_k[i])
#		data["time"].append(method3(delp))
#	n_p=n_p+1
#
#	#
#	#PLOT
#	#
#
#	#DATAFRAME
#	labels=[k]+metrics+["time"]
#	df = pd.DataFrame(data,columns=labels)
#
#	#MATRIXES
#	matrix_pearson = df.corr(method='pearson')
#	#matrix_kendall = df.corr(method='kendall')
#	matrix_spearman = df.corr(method='spearman')
#	matrix_cov = df.cov()
#
#	#PRINT THE PLOTS FOR EACH PARAMETER
#	print_matrix_plot(labels,matrix_pearson,(dir+"plot_pearson_"+k+".png"))
#	#print_matrix_plot(labels,matrix_kendall,(dir+"plot_kendall_"+k+".png"))
#	print_matrix_plot(labels,matrix_spearman,(dir+"plot_spearman_"+k+".png"))
#	print_matrix_plot(labels,matrix_cov,(dir+"plot_cov_"+k+".png"))
#	
#	
#
#######
####### GENERATING PLOTS FOR STEP 2  (i.e., TIMES of the whole dataset over metrics)
#######
#for k in d.keys():
#	data = {m:[] for m in metrics}
#	data["time"]=[]
#	for delp in d[k]:
#		metrics_d_k=method2(delp)
#		for i in range(len(metrics_d_k)):
#			data[metrics[i]].append(metrics_d_k[i])
#		data["time"].append(method3(delp))
#
#
#	#PLOT
#	labels=metrics+["time"]
#	df = pd.DataFrame(data,columns=labels)
#	
#	#MATRIXES
#	matrix_pearson = df.corr(method='pearson')
#	#matrix_kendall = df.corr(method='kendall')
#	matrix_spearman = df.corr(method='spearman')
#	matrix_cov = df.cov()
#
#
#	#PRINT THE PLOTS FOR EACH PARAMETER
#	print_matrix_plot(labels,matrix_pearson,(dir+"plot_time_pearson_"+k+".png"))
#	#print_matrix_plot(labels,matrix_kendall,(dir+"plot_time_kendall_"+k+".png"))
#	print_matrix_plot(labels,matrix_spearman,(dir+"plot_time_spearman_"+k+".png"))
#	print_matrix_plot(labels,matrix_cov,(dir+"plot_time_cov_"+k+".png"))

# To test
dp = '../dpgtest/'
parameters = [1,0.1,0.1,0.1,1,1,1,2,1,1]
#print(method1(dp, parameters))
print(create_datasets(dp))
